// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Ronin Bridge â€” Simplified Multisig Bridge
/// @notice Educational simulation of Ronin Bridge's validator multisig mechanism.
///         The real exploit was an off-chain key compromise, not a smart contract bug.

contract SimplifiedBridge {
    uint256 public constant THRESHOLD = 5;
    uint256 public constant TOTAL_VALIDATORS = 9;

    mapping(address => bool) public isValidator;
    address[] public validators;
    uint256 public validatorCount;

    // Withdrawal tracking
    struct Withdrawal {
        address to;
        uint256 amount;
        uint256 approvals;
        mapping(address => bool) hasApproved;
        bool executed;
    }

    uint256 public withdrawalNonce;
    mapping(uint256 => Withdrawal) public withdrawals;

    event ValidatorAdded(address indexed validator);
    event WithdrawalRequested(uint256 indexed nonce, address to, uint256 amount);
    event WithdrawalApproved(uint256 indexed nonce, address indexed validator);
    event WithdrawalExecuted(uint256 indexed nonce, address to, uint256 amount);

    constructor(address[] memory _validators) {
        require(_validators.length == TOTAL_VALIDATORS, "Need exactly 9 validators");
        for (uint256 i = 0; i < _validators.length; i++) {
            isValidator[_validators[i]] = true;
            validators.push(_validators[i]);
        }
        validatorCount = TOTAL_VALIDATORS;
    }

    receive() external payable {}

    function requestWithdrawal(address to, uint256 amount) external returns (uint256) {
        require(isValidator[msg.sender], "Not a validator");
        uint256 nonce = withdrawalNonce++;
        Withdrawal storage w = withdrawals[nonce];
        w.to = to;
        w.amount = amount;
        emit WithdrawalRequested(nonce, to, amount);
        return nonce;
    }

    function approveWithdrawal(uint256 nonce) external {
        require(isValidator[msg.sender], "Not a validator");
        Withdrawal storage w = withdrawals[nonce];
        require(!w.executed, "Already executed");
        require(!w.hasApproved[msg.sender], "Already approved");

        w.hasApproved[msg.sender] = true;
        w.approvals++;

        emit WithdrawalApproved(nonce, msg.sender);

        // Auto-execute when threshold is reached
        if (w.approvals >= THRESHOLD) {
            w.executed = true;
            (bool success,) = w.to.call{value: w.amount}("");
            require(success, "Transfer failed");
            emit WithdrawalExecuted(nonce, w.to, w.amount);
        }
    }
}
